#!/usr/bin/env python

from stbt import ArgvHider, debug, load_defaults, save_frame, uri_to_remote, \
    uri_to_remote_recorder

with ArgvHider():
    import pygst  # gstreamer
    pygst.require("0.10")
    import gst

import argparse
import itertools
import sys


def main(argv):
    parser = argparse.ArgumentParser('Create an stb-tester test script')
    parser.add_argument('--control',
        help='The remote control to control the stb (default: %(default)s)')
    parser.add_argument('--control-recorder',
        help='The remote control to control the stb (default: %(default)s)')
    parser.add_argument('--source-pipeline',
        help='A gstreamer pipeline to use for A/V input (default: '
             '%(default)s)')
    parser.add_argument('--sink-pipeline',
        help='A gstreamer pipeline to use for video output '
             '(default: %(default)s)')
    parser.add_argument('-o', '--output-file',
        help='The filename of the generated script (default: %(default)s)')
    parser.set_defaults(**load_defaults('record'))
    args = parser.parse_args(argv[1:])
    debug("Arguments:\n" + "\n".join([
                "%s: %s" % (k, v) for k, v in args.__dict__.items()]))

    record(args.source_pipeline, args.sink_pipeline,
           uri_to_remote_recorder(args.control_recorder),
           uri_to_remote(args.control), open(args.output_file, 'w'))


def record(video_source, video_sink, remote_input, control, script_out):
    count = itertools.count()
    old_key = None
    display = " ".join([video_source,
                        " ! tee name=t",
                        " ! queue leaky=2",
                        " ! ffmpegcolorspace",
                        " ! appsink name=screenshot "
                                   "max-buffers=1 drop=true sync=false "
                                   "caps=video/x-raw-rgb",
                        " t. ! queue leaky=2 ! ", video_sink,
                        ])
    pipeline = gst.parse_launch(display)
    screenshot = pipeline.get_by_name("screenshot")
    pipeline.get_bus().connect("message::error", on_error)
    pipeline.get_bus().connect("message::warning", on_warning)
    pipeline.set_state(gst.STATE_PLAYING)
    while True:
        interrupt = False
        try:
            key = remote_input.next()
        except KeyboardInterrupt:
            interrupt = True
        buf = screenshot.get_property('last-buffer')
        control.press(key)
        if old_key:
            filename = '%04d-%s-complete.png' % (count.next(), old_key)
            save_frame(buf, filename)
            script_out.write("wait_for_match('%s')\n" % filename)
        if interrupt:
            return
        script_out.write("press('%s')\n" % key)
        old_key = key


def on_error(bus, message):
    assert message.type == gst.MESSAGE_ERROR
    err, dbg = message.parse_error()
    sys.stderr.write("Error: %s\n%s\n" % (err, dbg))
    sys.exit(1)


def on_warning(bus, message):
    assert message.type == gst.MESSAGE_WARNING
    err, dbg = message.parse_warning()
    sys.stderr.write("Warning: %s\n%s\n" % (err, dbg))


if __name__ == "__main__":
    sys.exit(main(sys.argv))
