#!/usr/bin/env python

"""
Copyright 2012-2013 YouView TV Ltd.
License: LGPL v2.1 or (at your option) any later version (see
https://github.com/drothlis/stb-tester/blob/master/LICENSE for details).
"""

import stbt

import pygst  # gstreamer
pygst.require("0.10")
with stbt.hide_argv(), stbt.hide_stderr():
    import gst

import itertools
import sys
import time


def main(argv):
    parser = stbt.argparser()
    parser.prog = 'stbt record'
    parser.description = 'Create an stb-tester test script'
    parser.add_argument(
        '--control-recorder',
        default=stbt.get_config('control_recorder', section='record'),
        help='The source of remote control keypresses (default: %(default)s)')
    parser.add_argument(
        '-o', '--output-file',
        default=stbt.get_config('output_file', section='record'),
        help='The filename of the generated script (default: %(default)s)')
    args = parser.parse_args(argv[1:])
    stbt.debug("Arguments:\n" + "\n".join([
        "%s: %s" % (k, v) for k, v in args.__dict__.items()]))

    display = Display(args.source_pipeline, args.sink_pipeline)

    try:
        script = open(args.output_file, 'w')
    except IOError as e:
        e.strerror = "Failed to write to output-file '%s': %s" % (
            args.output_file, e.strerror)
        raise

    record(display,
           stbt.uri_to_remote_recorder(args.control_recorder),
           stbt.uri_to_remote(args.control, display),
           script)


def record(display, remote_input, control, script_out):
    count = itertools.count()
    old_key = None
    script_out.write("import stbt\n\n\n")
    while True:
        interrupt = False
        try:
            key = remote_input.next()
        except (KeyboardInterrupt, StopIteration):
            interrupt = True
        buf = display.screenshot.get_property('last-buffer')
        if not interrupt:
            if not buf:
                sys.stderr.write(
                    "No frame in frame buffer. Unable to take screenshot.\n"
                    "Key press event '%s' not being sent.\n" % key)
                continue
            control.press(key)
        if old_key:
            filename = '%04d-%s-complete.png' % (count.next(), old_key)
            stbt.save_frame(buf, filename)
            script_out.write("stbt.wait_for_match('%s')\n" % filename)
        if interrupt:
            return
        script_out.write("stbt.press('%s')\n" % key)
        old_key = key


class Display:
    def __init__(self, video_source, video_sink):
        self.pipe = " ".join([
            video_source,
            " ! tee name=t",
            " t. ! queue leaky=2",
            "    ! ffmpegcolorspace",
            "    ! appsink name=screenshot max-buffers=1 drop=true "
            "sync=false caps=video/x-raw-rgb",
            " t. ! queue leaky=2 ! ffmpegcolorspace ! ", video_sink
        ])
        self.pipeline = gst.parse_launch(self.pipe)
        self.screenshot = self.pipeline.get_by_name("screenshot")
        self.pipeline.get_bus().connect("message::error", self.on_error)
        self.pipeline.get_bus().connect("message::warning", self.on_warning)
        self.pipeline.set_state(gst.STATE_PLAYING)

        attempts = 0
        while True:
            time.sleep(1)  # minimum time needed for pipeline to start
            if self.screenshot.get_property("last-buffer"):
                break
            elif attempts < 5:
                attempts += 1
                sys.stderr.write(
                    "Unable to get frame buffer, attempt %d\n"
                    "Retrying in 5 seconds...\n" % (attempts))
                self.pipeline.set_state(gst.STATE_NULL)
                time.sleep(5)
                self.pipeline = gst.parse_launch(self.pipe)
                self.screenshot = self.pipeline.get_by_name("screenshot")
                self.pipeline.get_bus().connect(
                        "message::error", self.on_error)
                self.pipeline.get_bus().connect(
                        "message::warning", self.on_warning)
                self.pipeline.set_state(gst.STATE_PLAYING)
                continue
            sys.stdout.write("Unable to get frame buffer! Exiting...\n")
            sys.exit(1)

    @staticmethod
    def on_error(_bus, message):
        assert message.type == gst.MESSAGE_ERROR
        err, dbg = message.parse_error()
        sys.stderr.write("Error: %s: %s\n%s\n" % (err, err.message, dbg))
        sys.exit(1)

    @staticmethod
    def on_warning(_bus, message):
        assert message.type == gst.MESSAGE_WARNING
        err, dbg = message.parse_warning()
        sys.stderr.write("Warning: %s: %s\n%s\n" % (err, err.message, dbg))


if __name__ == "__main__":
    sys.exit(main(sys.argv))
