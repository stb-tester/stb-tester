#!/usr/bin/env python

"""
Copyright 2012-2013 YouView TV Ltd.
License: LGPL v2.1 or (at your option) any later version (see
https://github.com/stb-tester/stb-tester/blob/master/LICENSE for details).
"""

import argparse
import os
import sys
import traceback

import stbt

parser = stbt.argparser()
parser.prog = 'stbt run'
parser.description = 'Run an stb-tester test script'
parser.add_argument(
    '--save-video', help='Record video to the specified file', metavar='FILE',
    default=stbt.get_config('run', 'save_video'))
parser.add_argument(
    'script', metavar='FILE[::TESTCASE]', help=(
        "The python test script to run. Optionally specify a python function "
        "name to run that function; otherwise only the script's top-level will "
        "be executed."))
parser.add_argument(
    'args', nargs=argparse.REMAINDER, metavar='ARG',
    help='Additional arguments passed on to the test script (in sys.argv)')

args = parser.parse_args(sys.argv[1:])
sys.argv[1:] = args.args
stbt.debug("Arguments:\n" + "\n".join([
    "%s: %s" % (k, v) for k, v in args.__dict__.items()]))


def _setup_utf8_output():
    """
    Simulates python3's defaulting to utf-8 output so we don't get confusing
    `UnicodeEncodeError`s when printing unicode characters.
    """
    import codecs
    if sys.stdout.encoding is None:
        sys.stdout = codecs.getwriter('utf8')(sys.stdout)
    if sys.stderr.encoding is None:
        sys.stderr = codecs.getwriter('utf8')(sys.stderr)

_setup_utf8_output()


def import_by_filename(filename_):
    module_dir, module_file = os.path.split(filename_)
    module_name, module_ext = os.path.splitext(module_file)
    if module_ext != '.py':
        raise ImportError("Invalid module filename '%s'" % filename_)
    sys.path = [os.path.abspath(module_dir)] + sys.path
    return __import__(module_name)


def report_exception(script_name, exc, message):
    """Print the script's failing exception."""
    sys.stdout.write("FAIL: %s: %s: %s\n" % (
        script_name, type(exc).__name__, message))


def report_failures():
    """Print a list of failures which were registered during test execution.

    If failures have been registered, a UITestFailure exception is created and
    returned to the caller along with an integer representing a exit code which
    can be raised to indicate that failures were registered during test
    execution and the nature of the failures.

    If no failures have been registered, the return is (None, 0).

    :rtype: (Exception, int)
    """
    ret_exception = None
    exit_codes = []
    for i, failure in enumerate(stbt.get_registered_failures()):
        if i == 0:  # First loop only
            sys.stderr.write("Failures registered during test execution:\n")

        sys.stderr.write("%s\n" % failure)

        if failure.screenshot is not None:
            screenshot_file = "%s_%s.png" % (
                # Is it sensible to assume that push failures *won't* occur
                # in the same second? It seems redundant to add milliseconds
                # but there's nothing to stop this from happening.
                failure.timestamp.strftime("%Y-%m-%d_%H.%M.%S"),
                failure.classification)
            sys.stderr.write("Saved screenshot to '%s'.\n" % screenshot_file)
            stbt.save_frame(failure.screenshot, screenshot_file)

        exit_codes.append(failure.exit_status)
        if ret_exception is None:
            ret_exception = failure.exception if failure.exception is not None \
                else stbt.UITestFailure(
                    "Encountered a single failure during test execution.")
        else:
            ret_exception = stbt.UITestFailure(
                "Encountered multiple failures during test execution.")

    return ret_exception, min(exit_codes or (0,))


try:
    # pylint: disable=W0611

    stbt.init_run(
        args.source_pipeline, args.sink_pipeline, args.control,
        args.save_video, args.restart_source,
        stbt.get_config('global', 'transformation_pipeline'))

    if '::' in args.script:
        filename, function = args.script.split('::', 1)
        module = import_by_filename(filename)
        function = getattr(module, function)
        function()
    else:
        from stbt import (
            # For backwards compatibility. We want to encourage people to expli-
            # citly import stbt in their scripts, so don't add new APIs here.
            press, press_until_match, wait_for_match, wait_for_motion,
            detect_match, MatchResult, Position, detect_motion, MotionResult,
            save_frame, get_frame, MatchParameters,
            debug, UITestError, UITestFailure, MatchTimeout, MotionTimeout,
            ConfigurationError)
        __file__ = args.script
        sys.path.insert(0, os.path.dirname(os.path.abspath(args.script)))
        execfile(args.script)
except Exception as e:  # pylint: disable=W0703
    report_failures()
    error_message = str(e)
    if not error_message and isinstance(e, AssertionError):
        error_message = traceback.extract_tb(sys.exc_info()[2])[-1][3]
    report_exception(args.script, e, error_message)
    if hasattr(e, "screenshot") and e.screenshot is not None:
        stbt.save_frame(e.screenshot, "screenshot.png")
        sys.stderr.write("Saved screenshot to '%s'.\n" % ("screenshot.png"))
    traceback.print_exc(file=sys.stderr)
    if isinstance(e, stbt.UITestFailure):
        sys.exit(1)  # Failure
    else:
        sys.exit(2)  # Error
else:
    exception, exit_code = report_failures()
    if exception is not None:
        report_exception(args.script, exception, str(exception))
    sys.exit(exit_code)
finally:
    stbt.teardown_run()
